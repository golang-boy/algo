/*

题目：

给定N个物品，其中第i个物品的体积为Vi,价值为Wi。 有一容积为M的背包，
要求选择放入一些物品，使得总体积不超过M时，物品价值总和最大
*/

package main

func main() {

	/*
	   f[i][j] 表示从前i个物品中选出总体积为j的物品放入背包，使物品总价值最大


	   转移方程:
	   f[i][j] = f[i-1][j] 不选第i个物品时，递推关系

	   if j-Vi >= 0 {
	   	   f[i][j] = f[i-1][j-Vi]+ Wi     j in [0,M]
	   }

	   递推初始值:
	   f[0][0] = 0

	   目标: max(f[n][j]),  j in [0,M]
	*/

	f := make([][]int, N+1)

	for i := range f {
		f[i] = make([]int, M+1)
	}

	for i := 1; i <= N; i++ {

		// 不选的情况时，前一个的价值和后一个的价值一样
		for j := 0; j <= M; j++ {
			f[i][j] = f[i-1][j]
		}
		// 要确保j>=v[i]
		for j := V[i]; j <= M; j++ {
			f[i][j] = max(f[i][j], f[i-1][j-V[i]]+W[i])

		}
	}

	ans := 0
	for j := 0; j <= M; j++ {
		ans = max(ans, f[n][j])
	}

	// 上述程序中 在不选时，第[i-1]行的值赋值给第i行, 然后进行后续选择时的操作
	// 此处可以简化掉第1维

	// 代码如下

	f[0] = 0
	for i := 1; i <= N; i++ {

		// 注意此处需要倒序, 为什么？
		for j := M; j >= V[i]; j-- {

			// 这里f[j]的更新，每次都取最大值，f[j] 肯定比后面的大。
			//   一轮循环完毕，计算下一轮，然后和上一轮的比较大小，取最大值, 直到f[0]
			f[j] = max(f[j], f[j-V[j]]+W[i])
		}

		// 结论： 0/1背包问题，简化后必须倒序处理内层循环
		//
		//    背包问题是选不选的问题，属于子集问题

		// f[M] = f[M-V[j]] + W[i]
		// f[M-V[j]]  = f[M-V[j] - V[j-1]] + W[i] +W[i]
	}

	ans := 0

	for j := 0; j <= M; j++ {
		ans = max(ans, f[j])
	}
	return ans
}
